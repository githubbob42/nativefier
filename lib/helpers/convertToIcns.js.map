{"version":3,"sources":["helpers/convertToIcns.js"],"names":["isOSX","setGracefulCleanup","PNG_TO_ICNS_BIN_PATH","join","__dirname","convertToIcns","pngSrc","icnsDest","callback","exec","silent","exitCode","stdOut","stdError","includes","convertToIcnsTmp","tempIconDirObj","dirSync","unsafeCleanup","tempIconDirPath","name"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;;;AACA,IAAMA,QAAQ,kBAAQA,KAAtB;AACA,cAAIC,kBAAJ;;AAEA,IAAMC,uBAAuB,eAAKC,IAAL,CAAUC,SAAV,EAAqB,OAArB,EAA8B,mBAA9B,CAA7B;;AAEA;;;;;;AAMA;;;;;;AAMA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmD;AAC/C,QAAI,CAACR,OAAL,EAAc;AACVQ,iBAAS,+CAAT,EAA0DF,MAA1D;AACA;AACH;;AAED,sBAAMG,IAAN,CAAcP,oBAAd,SAAsCI,MAAtC,SAAgDC,QAAhD,EAA4D,EAACG,QAAQ,IAAT,EAA5D,EAA4E,UAACC,QAAD,EAAWC,MAAX,EAAmBC,QAAnB,EAAgC;AACxG,YAAID,OAAOE,QAAP,CAAgB,oBAAhB,KAAyCH,QAA7C,EAAuD;AACnD,gBAAIA,QAAJ,EAAc;AACVH,yBAAS;AACLI,4BAAQA,MADH;AAELC,8BAAUA;AAFL,iBAAT,EAGGP,MAHH;AAIA;AACH;;AAEDE,qBAASI,MAAT,EAAiBN,MAAjB;AACA;AACH;;AAEDE,iBAAS,IAAT,EAAeD,QAAf;AACH,KAfD;AAgBH;;AAED;;;;;AAKA,SAASQ,gBAAT,CAA0BT,MAA1B,EAAkCE,QAAlC,EAA4C;AACxC,QAAMQ,iBAAiB,cAAIC,OAAJ,CAAY,EAACC,eAAe,IAAhB,EAAZ,CAAvB;AACA,QAAMC,kBAAkBH,eAAeI,IAAvC;AACAf,kBAAcC,MAAd,EAAyBa,eAAzB,iBAAsDX,QAAtD;AACH;;kBAEcO,gB","file":"helpers/convertToIcns.js","sourcesContent":["import shell from 'shelljs';\nimport path from 'path';\nimport tmp from 'tmp';\nimport helpers from './helpers';\nconst isOSX = helpers.isOSX;\ntmp.setGracefulCleanup();\n\nconst PNG_TO_ICNS_BIN_PATH = path.join(__dirname, '../..', 'bin/convertToIcns');\n\n/**\n * @callback pngToIcnsCallback\n * @param error\n * @param {string} icnsDest If error, will return the original png src\n */\n\n/**\n *\n * @param {string} pngSrc\n * @param {string} icnsDest\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcns(pngSrc, icnsDest, callback) {\n    if (!isOSX()) {\n        callback('OSX is required to convert .png to .icns icon', pngSrc);\n        return;\n    }\n\n    shell.exec(`${PNG_TO_ICNS_BIN_PATH} ${pngSrc} ${icnsDest}`, {silent: true}, (exitCode, stdOut, stdError) => {\n        if (stdOut.includes('icon.iconset:error') || exitCode) {\n            if (exitCode) {\n                callback({\n                    stdOut: stdOut,\n                    stdError: stdError\n                }, pngSrc);\n                return;\n            }\n\n            callback(stdOut, pngSrc);\n            return;\n        }\n\n        callback(null, icnsDest);\n    });\n}\n\n/**\n * Converts the png to a temporary directory which will be cleaned up on process exit\n * @param {string} pngSrc\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcnsTmp(pngSrc, callback) {\n    const tempIconDirObj = tmp.dirSync({unsafeCleanup: true});\n    const tempIconDirPath = tempIconDirObj.name;\n    convertToIcns(pngSrc, `${tempIconDirPath}/icon.icns`, callback);\n}\n\nexport default convertToIcnsTmp;\n"],"sourceRoot":"/source/"}